#   JS
#### В этом проекте описаны методы объекта, "this". 

<hr>


<br>


#### Пример методов.

```js
  let user = {
  name: "Джон",
  age: 30
  };

  user.sayHi = function() { // Свойству sayHi объекта user присваиваем функцию которая выводит сообщение "Привет!" 
  alert("Привет!");
  };

  user.sayHi(); // Привет! // Вызываем эту функцию
```

### Объектно-ориентированное программирование
<hr>

Когда мы пишем наш код, используя объекты для представления сущностей реального мира, – это называется объектно-ориентированное программирование или сокращённо: «ООП».

ООП является большой предметной областью и интересной наукой само по себе. Как выбрать правильные сущности? Как организовать взаимодействие между ними? Это – создание архитектуры, и есть хорошие книги по этой теме, такие как «Приёмы объектно-ориентированного проектирования. Паттерны проектирования» авторов Эрих Гамма, Ричард Хелм, Ральф Джонсон, Джон Влиссидес или «Объектно-ориентированный анализ и проектирование с примерами приложений» Гради Буча, а также ещё множество других книг.

Сокращённая запись метода
```js
Существует более короткий синтаксис для методов в литерале объекта:
// эти объекты делают одно и то же (одинаковые методы)

user1 = {
  sayHi: function() {
    alert("Привет");
  }
};

// сокращённая запись выглядит лучше, не так ли?
user1 = {
  sayHi() { // то же самое, что и "sayHi: function()"
    alert("Привет");
  }
};
```

### Ключевое слово «this» в методах

Для доступа к информации внутри объекта метод может использовать ключевое слово this.

```js

let user = {
  name: "Джон",
  age: 30,

  sayHi() {
    // this - это "текущий объект"
    alert(this.name);
  }

};

user.sayHi(); // Джон

```


### «this» не является фиксированным
```js
let user = { name: "Джон" };
let admin = { name: "Админ" };

function sayHi() {
  alert( this.name );
}

// используем одну и ту же функцию в двух объектах
user.f = sayHi;
admin.f = sayHi;

// вызовы функции, приведённые ниже, имеют разное значение this
// "this" внутри функции является ссылкой на объект, который указан "перед точкой"
user.f(); // Джон  (this == user)
admin.f(); // Админ  (this == admin)

admin['f'](); // Админ (неважен способ доступа к методу - через точку или квадратные скобки)
```

#### Вызов без объекта: this == undefined

Мы даже можем вызвать функцию вовсе без использования объекта:
```js
function sayHi() { // Без использования директивы "use strict" выведет глобальный объект window. С этой директивой выведет undefined
  alert(this);
}

sayHi(); // undefined
```
### У стрелочных функций нет «this»

Стрелочные функции особенные: у них нет своего «собственного» this. Если мы используем this внутри стрелочной функции, то его значение берётся из внешней «нормальной» функции.

Например, здесь arrow() использует значение this из внешнего метода user.sayHi():
```js
let user = {
  firstName: "Илья",
  sayHi() {
    let arrow = () => alert(this.firstName);
    arrow();
  }
};

user.sayHi(); // Илья
```

### Итого
<hr>


Функции, которые находятся в объекте в качестве его свойств, называются «методами».
Методы позволяют объектам «действовать»: object.doSomething().
Методы могут ссылаться на объект через this.
Значение this определяется во время исполнения кода.

При объявлении любой функции в ней можно использовать this, но этот this не имеет значения 
до тех пор, пока функция не будет вызвана.
Эта функция может быть скопирована между объектами (из одного объекта в другой).
Когда функция вызывается синтаксисом «метода» – object.method(), значением this во время вызова 
является объект перед точкой.
Также ещё раз заметим, что стрелочные функции являются особенными – у них нет this. Когда внутри 
стрелочной функции обращаются к this, то его значение берётся снаружи.